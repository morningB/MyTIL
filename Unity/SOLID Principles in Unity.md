# 유튜브 영상보며 SOLID 요약하기

## 링크 : https://www.youtube.com/watch?v=eIf3-aDTOOA

주제: Unity 개발에서 SOLID 적용하기
- 사용 이유: 관리하기 쉬운 프로그램을 구축, 코드 유지보수성, 확장성, 테스트 용이성 향상

## Bob의 문제점: SOLID 원칙을 적용하지 않았을 때의 어려움

- 잦은 변경 사항: 새로운 클래스를 추가할 때마다 기존 코드에 많은 변경 사항을 적용해야 했습니다 ([00:04:06]). 
    - 이는 코드 베이스가 커질수록 더욱 심각해지는 문제입니다.

- 예상치 못한 버그: 한 줄의 코드를 업데이트했는데도 여러 곳에서 버그가 발생했습니다 ([00:04:27]). 
    - 이는 코드의 결합도가 높아 한 부분의 변경이 다른 부분에 연쇄적인 영향을 미치기 때문입니다.

- 기존 기능 손상: 새로운 기능을 추가하면 기존에 잘 작동하던 기능이 손상되는 일이 빈번했습니다 ([00:04:39]).
    - 이는 기능 간의 의존성이 복잡하게 얽혀있기 때문에 발생합니다.

- 테스트의 어려움: 코드에 대한 단위 테스트를 작성하기가 매우 어려웠습니다 ([00:04:47]).
    - 이는 클래스들이 너무 많은 책임을 지고 서로 강하게 의존하기 때문입니다.

- 코드 이해의 어려움: 다른 개발자가 Bob의 코드를 이해하고 작업하기가 매우 어려웠습니다 ([00:05:00]). 
    - 이는 코드의 가독성과 구조가 좋지 않기 때문입니다.

- 이러한 문제들은 결국 개발 속도 저하, 버그 증가, 팀워크 저해로 이어지며 프로젝트의 실패 위험을 높입니다.

## SOLID 원칙 상세 해설
SOLID는 객체 지향 프로그래밍의 5가지 핵심 원칙의 약자입니다. 각 원칙은 코드의 품질을 높이고 위에서 언급된 'Bob의 문제점'을 해결하는 데 기여합니다.

### 1. 의존성 역전 원칙 (Dependency Inversion Principle - DIP)

- 정의: 
1. "고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 
2. 이들 모두 추상화에 의존해야 한다. 추상화는 구체적인 것에 의존해서는 안 된다. 
3. 구체적인 것은 추상화에 의존해야 한다." ([00:11:05])

- 핵심: 구체적인 인스턴스(클래스)에 직접 의존하는 대신, 인터페이스나 추상 클래스와 같은 '추상화'에 의존해야 합니다.

- Unity 적용:
    - Unity Inspector는 인터페이스를 직접적으로 지원하지 않습니다. 
    - 따라서 디자이너 친화적인 설정을 위해서는 인터페이스 대신 추상 클래스를 사용하는 것이 더 실용적일 수 있습니다 ([00:12:03]).

- 예시: Enemy 클래스가 특정 Weapon 클래스에 직접 의존하는 대신, IWeapon 인터페이스(또는 추상 Weapon 클래스)에 의존하게 하여 다양한 종류의 무기를 유연하게 교체할 수 있도록 합니다.

### 2. 인터페이스 분리 원칙 (Interface Segregation Principle - ISP)

- 정의: "클라이언트는 자신이 사용하지 않는 메서드에 의존해서는 안 된다." ([00:13:04])

- 핵심: 크고 일반적인 인터페이스를 작고 구체적인 여러 인터페이스로 분리해야 합니다. 이를 통해 클라이언트(인터페이스를 구현하거나 사용하는 클래스)는 자신이 필요한 메서드만 알게 됩니다.

- Unity 적용:

- 인터페이스는 하나의 목적만을 가져야 합니다 ([00:14:55]). 
    - 예를 들어, IMoveable과 IAttackable 인터페이스를 분리하여, 이동만 가능한 객체는 IMoveable만 구현하고, 공격만 가능한 객체는 IAttackable만 구현하도록 합니다.

- 이렇게 하면 특정 클래스가 필요 없는 메서드를 강제로 구현해야 하는 상황을 피할 수 있으며, 코드의 응집도를 높이고 결합도를 낮출 수 있습니다.

### 3. 단일 책임 원칙 (Single Responsibility Principle - SRP)

- 정의: "모든 모듈 또는 클래스는 소프트웨어에서 제공하는 기능의 단일 부분에 대한 책임을 져야 하며, 그 책임은 클래스에 완전히 캡슐화되어야 한다." ([00:17:09])

- 핵심: 클래스는 오직 하나의 변경 이유만 가져야 합니다. 즉, 클래스는 '하나의 일'만 해야 합니다 ([00:18:44]).

- Unity 적용:

- Unity에서는 이를 컴포넌트처럼 생각할 수 있습니다 ([00:20:01]). Unity의 GameObject에 여러 Component를 붙여 기능을 확장하는 방식 자체가 SRP를 잘 따르는 예시입니다.

- 예시: Player 클래스 하나에 이동, 공격, 인벤토리 관리, UI 업데이트 등 모든 기능을 넣는 대신, PlayerMovement, PlayerAttack, InventoryManager, UIManager와 같은 별도의 클래스(또는 Unity 컴포넌트)로 분리합니다. 각 클래스는 자신의 단일 책임에만 집중합니다.

### 4. 개방-폐쇄 원칙 (Open-Closed Principle - OCP)

- 정의: "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해 개방적이어야 하지만 수정에 대해서는 폐쇄적이어야 한다." ([00:24:10])

- 핵심: 한 번 작성된 클래스는 다시 변경할 필요 없이 새로운 기능을 추가하거나 기존 기능을 확장할 수 있어야 합니다 ([00:24:31]).

- Unity 적용:

- 상속, 인터페이스, 전략 패턴 등을 활용하여 기존 코드를 수정하지 않고도 새로운 동작을 추가할 수 있도록 설계합니다.

- 예시: 다양한 적 AI를 구현할 때, EnemyAI 추상 클래스(또는 인터페이스)를 정의하고, 각 적의 유형에 따라 MeleeEnemyAI, RangedEnemyAI 등으로 확장하여 새로운 AI를 추가할 때 기존 EnemyAI 코드를 수정할 필요가 없도록 합니다.

### 5. 리스코프 치환 원칙 (Liskov Substitution Principle - LSP)

- 정의: "S가 T의 하위 타입이라면, T 타입의 객체는 S 타입의 객체로 대체될 수 있어야 하며, T의 바람직한 속성(정확성, 수행된 작업 등)을 변경하지 않아야 한다." ([00:26:48])

- 핵심: 부모 클래스의 객체를 자식 클래스의 객체로 대체해도 프로그램의 동작이 올바르게 유지되어야 합니다. 이는 상속을 적용할 때와 적용하지 않을 때를 결정하는 데 중요한 지침이 됩니다 ([00:30:29]).

- Unity 적용:

- 상속 관계에서 자식 클래스가 부모 클래스의 계약(기대되는 동작)을 위반하지 않도록 주의해야 합니다.

- 예시: 
    1. Bird 클래스에 Fly() 메서드가 있고, Penguin 클래스가 Bird를 상속받는다고 가정합니다. 
    2. Penguin은 날 수 없으므로 Fly() 메서드를 구현할 때 예외를 발생시키거나 아무것도 하지 않도록 할 수 있습니다. 
    3. 하지만 이는 LSP를 위반하는 것입니다. 이런 경우 Flyable 인터페이스를 별도로 만들고 Bird와 Penguin은 이를 선택적으로 구현하도록 하는 것이 더 올바른 설계입니다.

### 6. 의존성 주입 (Dependency Injection - DI)

- SOLID 원칙을 효과적으로 적용하기 위한 다음 단계로 의존성 주입(DI)이 소개됩니다.

- 정의: DI는 클래스가 자신이 어떤 것을 구성해야 하는지 알 필요가 없도록 하는 디자인 패턴입니다 ([00:32:57]). 
- 대신, 필요한 의존성을 외부에서 주입받습니다.

- 기존 DI 프레임워크의 한계: Ninject와 같은 일반적인 DI 프레임워크는 Unity에서 직접 작동하지 않는 경우가 많습니다 ([00:33:46]).

- Unity용 DI 시스템: 발표자는 Unity에서 작동하는 자체 DI 시스템을 소개하며, 이 시스템의 소스 코드는 GitHub에서 확인할 수 있다고 언급합니다 ([00:34:05]).

- DI의 장점: DI를 통해 클래스는 필요한 객체를 직접 생성하거나 찾는 대신 외부에서 주입받을 수 있습니다 ([00:35:09]). 
- 이는 다음과 같은 이점을 제공합니다.
    - 결합도 감소: 클래스 간의 의존성이 느슨해집니다.
    - 유연성 증가: 의존성을 쉽게 교체하거나 변경할 수 있습니다.
    - 테스트 용이성: 특히 단위 테스트에서 모의(mock) 객체를 쉽게 주입하여 테스트 환경을 격리할 수 있습니다.

### 7. 단위 테스트 (Unit Testing)

- DI는 단위 테스트를 효과적으로 수행하기 위한 핵심적인 요소입니다.

- 테스트 범위 확장: 
    - DI를 통해 게임 로직의 100%를 테스트할 수 있게 됩니다 ([00:48:01]). 
    - 이는 Unity의 컴포넌트 라이프사이클에 묶이지 않고 핵심 로직을 분리하여 테스트할 수 있기 때문입니다.

- Mock 프레임워크 활용: Visual Studio에서 Mock 프레임워크(예: Moq)를 사용하여 인터페이스를 모의(mock)할 수 있습니다 ([00:50:43]).

- 테스트 효율성 증대: 실제 Unity 엔진을 로드하지 않고도 테스트를 실행할 수 있어 테스트 시간이 밀리초 단위로 단축됩니다 ([00:56:05]). 
    - 이는 개발자가 코드를 변경할 때마다 빠르게 피드백을 받고 버그를 조기에 발견하는 데 매우 중요합니다.

- 테스트 코드 작성의 중요성: 테스트 코드를 작성하는 것은 초기에는 시간이 더 걸릴 수 있지만, 장기적으로는 버그를 줄이고 유지보수 비용을 절감하며 코드의 안정성을 높이는 데 필수적입니다.

### 8. 결론 및 추가 자료

발표자는 Unity 개발에서 SOLID 원칙, 의존성 주입, 그리고 단위 테스트를 적용하는 것이 얼마나 중요한지 다시 한번 강조합니다. 이러한 원칙들은 코드의 품질을 높이고, 팀 협업을 용이하게 하며, 궁극적으로 더 나은 게임을 만드는 데 기여합니다.

오픈 소스 DI 시스템: 발표자가 개발한 Unity용 DI 시스템은 GitHub에서 오픈 소스로 제공되며, 커뮤니티의 기여를 환영한다고 언급합니다 ([00:59:48]). 이는 개발자들이 SOLID 원칙을 실제로 적용해볼 수 있는 좋은 기회를 제공합니다.